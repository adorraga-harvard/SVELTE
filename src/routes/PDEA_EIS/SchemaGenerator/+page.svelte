<script lang="ts">
  import { fade } from 'svelte/transition';

  // --- State Variables ---
  let isGenerating: boolean = false;
  let error: string | null = null;
  let generatedSchemas: string = '';

  // --- Core Utility: Alias Cleanup ---
  // This helper mirrors the logic discussed (stripping suffixes and prefixes)
  function cleanAlias(alias: string): string {
    // 1. Remove table alias prefix (if present, e.g., T1.column -> column)
    let cleanName = alias.split('.').pop() || alias;

    // 2. Remove common, verbose suffixes (e.g., 'region_name' -> 'region')
    // We keep poi_id as per our discussion, but strip general _name, _id, _title
    cleanName = cleanName.replace(/_(name|title|role)$/, '');

    // 3. Special case for generic identifiers: remove trailing _id (but not poi_id)
    if (cleanName.endsWith('_id') && cleanName !== 'poi_id') {
      cleanName = cleanName.slice(0, -3);
    }

    return cleanName;
  }

  // --- Core Logic: Mimicking Server-Side Schema Generation ---
  // NOTE: In a real SvelteKit app, this would be a POST request to /api/generate-schema
  // Here, we simulate the complex process and output the expected structure.

  async function generateSchema() {
    isGenerating = true;
    error = null;
    generatedSchemas = '';

    // 1. Placeholder for the FIVE BRIDGES to be traversed
    // This list mimics the input needed for the server to know which tables to analyze.
    const baseBridges = [
      'poi_syndicate_members',
      'cases_drugs',
      'operations_master_operators',
      'other_bridge_a',
      'other_bridge_b',
    ];

    console.log("Starting Schema Generation process...");

    // 2. Mocking the database traversal and complex SQL generation
    // In a real app, this fetch would hit your backend and return the fully structured JSON.
    try {
      // *********************************************************************************
      // CRITICAL STEP: SIMULATED BACKEND CALL
      // We are mocking a successful response structure that the backend would generate
      // after executing complex SQL against the INFORMATION_SCHEMA tables.
      // *********************************************************************************
      await new Promise(resolve => setTimeout(resolve, 1500)); // Simulate network latency

      const mockGeneratedData = baseBridges.map(name => ({
        name: name,
        topDescription: `Generated schema for ${name.replace(/_/g, ' ').toUpperCase()} data bridge.`,

        // This subQuery is the massive string containing all JOINs and ALIASES
        subQuery: `SELECT T1.poi_id, T2.gender_name AS gender, T3.title AS syndicate FROM poi_table AS T1 INNER JOIN lookup_gender AS T2 ON T1.gender_id = T2.gender_id INNER JOIN poi_syndicates AS T3 ON T1.syndicate_id = T3.id`,

        // This list comes from analyzing the subQuery's SELECT clause
        // It uses the raw aliases defined in the subQuery (e.g., 'syndicate')
        columns: [
          'poi_id',
          'gender',
          'syndicate',
          'date_joined',
          'is_active_flag' // Example of a boolean/flag column
        ]
      }));

      // 3. Post-Processing: Format the final output into a TypeScript string
      let tsCode = `// Generated by SchemaGenerator on ${new Date().toLocaleDateString()}\n\n`;
      tsCode += `export interface BridgeSchema {\n`;
      tsCode += `  name: string;\n`;
      tsCode += `  topDescription: string;\n`;
      tsCode += `  subQuery: string;\n`;
      tsCode += `  columns: string[];\n`;
      tsCode += `}\n\n`;
      tsCode += `export const bridgeSchemas: BridgeSchema[] = [\n`;

      mockGeneratedData.forEach((schema, index) => {
        // Map the raw aliases (like 'is_active_flag') to user-friendly names (like 'Is Active')
        const displayColumns = schema.columns.map(col => `'${cleanAlias(col)}'`).join(',\n    ');

        tsCode += `  {\n`;
        tsCode += `    name: '${schema.name}',\n`;
        tsCode += `    topDescription: '${schema.topDescription}',\n`;
        tsCode += `    // Complex SQL with all JOINs and T-aliases (not displayed here for brevity)\n`;
        tsCode += `    subQuery: \`${schema.subQuery}\`,\n`;
        tsCode += `    columns: [\n    ${displayColumns}\n    ]\n`;
        tsCode += `  }${index < mockGeneratedData.length - 1 ? ',' : ''}\n`;

      });

      tsCode += `];\n`;

      generatedSchemas = tsCode;

    } catch (e) {
      error = `Generation failed: ${(e as Error).message}`;
      console.error(e);
    } finally {
      isGenerating = false;
    }
  }

  // --- User Interaction: Copy to Clipboard ---
  function copyToClipboard() {
    if (!generatedSchemas) return;
    try {
      navigator.clipboard.writeText(generatedSchemas);
      alert('Schema code copied to clipboard!'); // Using simple alert for admin tool
    } catch (err) {
      error = 'Failed to copy text. Please select and copy manually.';
      console.error(err);
    }
  }
</script>

<style>
  /* Basic styling for the code block */
  .code-output {
    background-color: #2c3e50; /* Dark blue/grey background */
    color: #ecf0f1; /* Light text */
    font-family: 'Fira Code', 'Consolas', monospace;
    font-size: 0.85rem;
    padding: 1.5rem;
    border-radius: 0.5rem;
    white-space: pre-wrap;
    word-break: break-word;
    max-height: 70vh;
    overflow-y: auto;
  }

  .copy-btn {
    transition: transform 0.1s ease;
    box-shadow: 0 4px #1a2430;
  }

  .copy-btn:active {
    transform: translateY(2px);
    box-shadow: 0 2px #1a2430;
  }
</style>

<div class="p-8 max-w-7xl mx-auto space-y-6">
  <h1 class="text-4xl font-extrabold text-gray-800">
    LGU Schema Generator <span class="text-xl text-blue-600">â€” Admin Tool</span>
  </h1>
  <p class="text-gray-600 border-l-4 border-blue-400 pl-3 py-1 bg-blue-50">
    This tool automatically generates the `bridgeSchemas.ts` file by analyzing the database structure of the 5 core LGU bridges. It implements the agreed-upon rules for **mandatory aliasing** and **clean naming** (e.g., stripping `_name`, `_id`).
  </p>

  <div class="flex space-x-4 items-start">
    <button
      class="bg-green-600 text-white font-bold py-3 px-6 rounded-lg copy-btn hover:bg-green-700 disabled:bg-gray-400 flex items-center"
      on:click={generateSchema}
      disabled={isGenerating}
    >
      {#if isGenerating}
        <svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
          <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
          <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
        </svg>
        Generating Code...
      {:else}
        Start Schema Generation
      {/if}
    </button>

    {#if generatedSchemas}
      <button
        class="bg-blue-600 text-white font-bold py-3 px-6 rounded-lg copy-btn hover:bg-blue-700"
        on:click={copyToClipboard}
      >
        Copy Code to Clipboard
      </button>
    {/if}
  </div>

  {#if error}
    <p class="text-red-600 p-3 bg-red-100 rounded-md font-medium">Error: {error}</p>
  {/if}

  {#if generatedSchemas}
    <h2 class="text-2xl font-semibold pt-4">Generated `bridgeSchemas.ts` Content:</h2>
    <pre class="code-output">{generatedSchemas}</pre>
  {/if}
</div>
